<html lang="">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PolyForm</title>
    <style> 
    </style>
    <link rel="stylesheet" media="screen" href="defstylsh.css">
    <link rel="shortcut icon" type="image/jpg" href="painty.jpg">
    <script src="helper_functions.js"></script>
    <script src="https://d3js.org/d3.v4.min.js"></script>
  </head>
  <body>
      <div class="nav">
      <a href="index.php">Home</a>
      <a href="cards.php">Guessing Game</a>
      <a href="GUI-tar.php">GUI-tar</a>
      <a href="polyform.php" class="active">PolyForm</a>
      <a href="featured.php">Featured Arts</a>
      </div>
      <br>
      <div id="canvas">
      </div>
    </footer>
    </main>

  </body>

  
<script>
    /*TODO
      Instructions throw error when not sleeping, put slp 1 in textarea by default
      Create pushbutton input
      Create tlt tgt teq command
      Components should be click and draggable with left click
      Give controller a register
    */
    let screen_width  = screen.width;
    let width, height;
    let wires = [];
    let connections = {};
    let edit_mode = false;
    let curr_inst = "";
    let inst_index = 0;
    let i = 0;
    let sleep_timer = 0;
    let sleep = false;
    width = Math.floor(screen_width);
    height = Math.floor(screen_width);
    c_width = .75*width;
    c_height = .75*height;

    let canvas = d3.select("#canvas").append("svg")
                  .attr("width", c_width)
                  .attr("height", c_height);

    d3.select("#canvas").attr("style", "text-align:center;");
    let background = canvas.append("rect")
                      .attr("width", c_width)
                      .attr("height", c_height)
                      .attr("fill", "whitesmoke");

    class Component {
      constructor(x, y){
        this.x = x;
        this.y = y;
        this.contains = [];
        this.container = canvas.append("g")
                              .attr("x", x)
                              .attr("y", y);
      }

      draw(){
        this.contains.push(canvas.append("rect")
          .attr("x", this.x)
          .attr("y", this.y)
          .attr("width", 100)
          .attr("height", 100)
          .attr("fill", "black"));
      }

      delete(){
        for(let i = 0; i < this.contains.length; i++)
        {
          d3.select(this.contains[i]).node().remove();
        }
        this.contains = [];
      }
    };

    class LED extends Component{
      constructor(x, y){
        super(x,y)
        this.bulb = null;
        this.pin1 = null;
        this.pin2 = null;
        //this.powered = false;
        this.power = 0;
      }
      draw(){
        this.bulb = this.container.append("path")
          .attr("d", "M 5 5 H 50 Q 75 25 50 50 H 5 Z")
          .attr("fill", "red")
          .attr("style", 'transform: translate(' + this.x + 'px,' + this.y + 'px);');
        this.contains.push(this.bulb);
        this.pin1 = this.container.append("rect")
          .attr("width", 50)
          .attr("height", 10)
          .attr("x", this.x - 30)
          .attr('y', this.y + 10)
          .attr("fill", "gray")
          .attr("id", "pin1")
          .attr("data-px", this.x - 30)
          .attr('data-py', this.y + 10)
          .on("contextmenu", contextMenuCalled);
        this.contains.push(this.pin1);
        this.pin2 = this.container.append("rect")
          .attr("width", 50)
          .attr("height", 10)
          .attr("x", this.x-30)
          .attr('y', this.y+40)
          .attr("fill", "gray")
          .attr("id", "pin2")
          .attr("data-px", this.x - 30)
          .attr('data-py', this.y + 40)
          .on("contextmenu", contextMenuCalled);
        this.contains.push(this.pin2);
      }

    };

    class Controller extends Component{
      constructor(x,y){
        super(x,y)
        this.p0 = null;
        this.p1 = null;
        this.p2 = null;
        this.p3 = null;
        this.p0_x = this.x + 350;
        this.p0_y = this.y + 50;
        this.p1_x = this.x + 350;
        this.p1_y = this.y + 75;
        this.p2_x = this.x + 350;
        this.p2_y = this.y + 100;
        this.p3_x = this.x + 350;
        this.p3_y = this.y + 125;
        this.ground = null;
        this.ground_x = this.x + 350;
        this.ground_y = this.y + 150;
        this.ground2 = null;
        this.ground2_x = this.x + 350;
        this.ground2_y = this.y + 175;
        this.text_wrapper = null; 
        this.text_area = null;
        this.edit_mode = false;
        this.acc_box = null;
        this.acc_text = null;
        this.acc_label = null;
        this.acc_x = this.x + 250;
        this.acc_y = this.y + 50;
        this.acc_text_x = this.acc_x + 12;
        this.acc_text_y = this.acc_y + 45;
        this.acc_label_x = this.acc_text_x - 5;
        this.acc_label_y = this.acc_text_y - 30;
        this.acc = 0;
      }
      draw(){
        this.contains.push(this.container.append("rect")
          .attr("x", this.x)
          .attr("y", this.y)
          .attr("width", 400)
          .attr("height", 200)
          .attr("fill", "slategray"));
        this.contains.push(this.container.append("rect")
          .attr("x", this.x+25)
          .attr("y", this.y+25)
          .attr("width", 300)
          .attr("height", 150)
          .attr("fill", "lightgray"));
        this.contains.push(this.container.append("text")
          .attr("x", this.p0_x + 10)
          .attr("y", this.p0_y)
          .text("p0"));
        this.contains.push(this.container.append("text")
          .attr("x", this.p1_x + 10)
          .attr("y", this.p1_y)
          .text("p1"));
        this.contains.push(this.container.append("text")
          .attr("x", this.p2_x + 10)
          .attr("y", this.p2_y)
          .text("p2"));
        this.contains.push(this.container.append("text")
          .attr("x", this.p3_x + 10)
          .attr("y", this.p3_y)
          .text("p3"));
        this.contains.push(this.container.append("text")
          .attr("x", this.ground_x + 10)
          .attr("y", this.ground_y)
          .text("GND"));
        this.contains.push(this.container.append("text")
          .attr("x", this.ground2_x + 10)
          .attr("y", this.ground2_y)
          .text("GND"));
        this.p0 = this.container.append("circle")
          .attr("cx", this.p0_x)
          .attr("cy", this.p0_y)
          .attr("r", 5)
          .attr('width', 20)
          .attr('height', 20)
          .attr("fill", "yellow")
          .attr('id', "p0")
          .attr("data-px", this.p0_x)
          .attr('data-py', this.p0_y)
          .on("contextmenu", contextMenuCalled);
        this.p1 = this.container.append("circle")
          .attr("cx", this.p1_x)
          .attr("cy", this.p1_y)
          .attr("r", 5)
          .attr('width', 20)
          .attr('height', 20)
          .attr("fill", "yellow")
          .attr('id', "p1")
          .attr("data-px", this.p1_x)
          .attr('data-py', this.p1_y)
          .on("contextmenu", contextMenuCalled);
        this.p2 = this.container.append("circle")
          .attr("cx", this.p2_x)
          .attr("cy", this.p2_y)
          .attr("r", 5)
          .attr('width', 20)
          .attr('height', 20)
          .attr("fill", "yellow")
          .attr('id', "p2")
          .attr("data-px", this.p2_x)
          .attr('data-py', this.p2_y)
          .on("contextmenu", contextMenuCalled);
        this.p3 = this.container.append("circle")
          .attr("cx", this.p3_x)
          .attr("cy", this.p3_y)
          .attr("r", 5)
          .attr('width', 20)
          .attr('height', 20)
          .attr("fill", "yellow")
          .attr('id', "p3")
          .attr("data-px", this.p3_x)
          .attr('data-py', this.p3_y)
          .on("contextmenu", contextMenuCalled);
        this.contains.push(this.p0);
        this.contains.push(this.p1);
        this.contains.push(this.p2);
        this.contains.push(this.p3);
        this.ground = this.container.append("circle")
          .attr("cx", this.ground_x)
          .attr("cy", this.ground_y)
          .attr("r", 5)
          .attr('width', 20)
          .attr('height', 20)
          .attr("fill", "black")
          .attr('id', "ground")
          .attr("data-px", this.ground_x)
          .attr('data-py', this.ground_y)
          .on("contextmenu", contextMenuCalled);
        this.ground2 = this.container.append("circle")
          .attr("cx", this.ground2_x)
          .attr("cy", this.ground2_y)
          .attr("r", 5)
          .attr('width', 20)
          .attr('height', 20)
          .attr("fill", "black")
          .attr('id', "ground2")
          .attr("data-px", this.ground2_x)
          .attr('data-py', this.ground2_y)
          .on("contextmenu", contextMenuCalled);
        this.contains.push(this.ground);
        this.contains.push(this.ground2);
        this.text_wrapper = this.container.append('foreignObject')
          .attr('x', this.x + 30)
          .attr('y', this.y + 30)
          .attr('width', 200)
          .attr('height', 100)
        this.contains.push(this.text_wrapper);
        this.text_area = this.text_wrapper.append("xhtml:textarea")
          .attr('type','text')
          .attr('id', 'text_area')
          .attr('name','textInput')
          .attr('value','Text goes here')
          .attr("style", 'height:100px; width:200px;');
        let t = document.getElementById('text_area');
        t.addEventListener('input', () => {
          edit_mode = true;
          });
        this.contains.push(this.text_area);
        this.acc_box = this.container.append("rect")
                    .attr('x', this.acc_x)
                    .attr('y', this.acc_y)
                    .attr('width', 50)
                    .attr("height", 50)
                    .attr("fill", "silver");
        this.acc_text = this.container.append("text")
                          .attr("x", this.acc_text_x)
                          .attr("y", this.acc_text_y)
                          .text("000");
        this.acc_label = this.container.append("text")
                          .attr("x", this.acc_label_x)
                          .attr("y", this.acc_label_y)
                          .text("ACC");
        this.contains.push(this.acc_box);
        this.contains.push(this.acc_text);
        this.contains.push(this.acc_label);
      }
    };

    canvas.on("contextmenu", function(){
              d3.event.preventDefault();
        });

    let selected = [];

    function contextMenuCalled(){
      let index = selected.indexOf(this);
      if(index == -1)
      {
        selected.push(this);
        d3.select(this).attr('stroke-width', 3)
                       .attr('stroke', "gold");
      }
      else
      {
        selected.splice(index,1);
        d3.select(this).attr('stroke-width', 0);
      }
      if(this.id in connections)
      {
        for(wire of wires)
        {
          if(wire.attr("data-origin") == this.id || wire.attr("data-end") == this.id)
          {
            let wire_index = wires.indexOf(wire);
            delete connections[wire.attr("data-origin")];
            delete connections[wire.attr("data-end")];
            wire.remove();
            wires.splice(index,1);
          }
        }
      }
      if(selected.length > 1){
        wires.push(canvas.append('line')
                          .style("stroke", "lightgreen")
                          .style("stroke-width", 4)
                          .attr("x1", d3.select(selected[0]).attr("data-px"))
                          .attr("y1", d3.select(selected[0]).attr("data-py"))
                          .attr('x2', d3.select(selected[1]).attr("data-px"))
                          .attr("y2", d3.select(selected[1]).attr("data-py"))
                          .attr("data-origin", d3.select(selected[0]).attr("id"))
                          .attr("data-end", d3.select(selected[1]).attr('id')));
        connections[selected[0].id] = selected[1].id;
        connections[selected[1].id] = selected[0].id;


        for(sel of selected)
        {
          d3.select(sel).attr('stroke-width', 0);
        }
        selected = []
      }

    };

    let test = new Controller(20, 20);
    let led = new LED(250, 250);
    let components = [];
    components.push(test);
    components.push(led);
    components.forEach(comp => comp.draw());

    function processInput(tokens)
    {
      if(tokens[0] == "mov"){
          if(tokens[1])
          {
            if(connections[tokens[2]] == 'pin1' || connections[tokens[2]] == 'pin2'){
              let power = 0;
              if(tokens[1] == "acc") power = test.acc;
              else power = parseInt(tokens[1]);
              led.power = power;
            }
            else if(tokens[2] == 'acc')
            {
              test.acc = parseInt(tokens[1]);
              let prefix = "";
              if(test.acc < 100) prefix += "0";
              if(test.acc < 10) prefix += "0"
              test.acc_text.text(prefix + test.acc);
            }
          }}
      else if(tokens[0] == "slp")
      {
        if(i+1 < lines.length) inst_index = i+1;
        i++;
        sleep_timer = parseInt(tokens[1]);
        return i;
      }
      else if(tokens[0] == "add")
      {
        test.acc += parseInt(tokens[1]);
        console.log(parseInt(tokens[1]));
        console.log(test.acc);
        let prefix = "";
        if(test.acc < 100) prefix += "0";
        if(test.acc < 10) prefix += "0";
        test.acc_text.text(prefix + test.acc);
      }
      else if(tokens[0] == "teq")
        {
          let equal = false;
          if(tokens[1] == "acc" && test.acc == parseInt(tokens[2])) equal = true;
          else if(tokens[2] == "acc" && test.acc == parseInt(tokens[1])) equal = true;
          else if(parseInt(tokens[1]) == parseInt(tokens[2])) equal = true;
          if(equal)
          {
            i++;
            if(i < lines.length) tokens = lines[i].split(" ");
            while(i < lines.length && tokens[0] == "+")
            {
              console.log("recursive call")
              tokens = lines[i].split(" ");
              processInput(tokens.slice(1));
              i++;
            }
          }
        }
        i++;
    }

    const intervalId = setInterval(() => {
      let lines = [];
      if(sleep_timer)
      {
        sleep_timer--;
        return;
      }
      if(edit_mode == false)
      {
        let inst = test.text_area.node().value;
        if(curr_inst != inst)
        {
          curr_inst = inst;
          inst_index = 0;
        }
        lines = inst.split("\n");
        let i = inst_index;
        while(true)
        {
           if(led.power)
            {
              let fill_str = "rgb(255," + parseInt(led.power*2) + "," + parseInt(led.power*2) +")"; 
              led.bulb.attr("fill", fill_str);
            }
            else
            {
              led.bulb.attr("fill", "red");
            }
           sleep = false;
           for(let j = 0; j < lines.length; j++)
           {
            let slp_tok = lines[j].split(" ");
            if(slp_tok[0] == "slp" && parseInt(slp_tok[1]) > 0) sleep = true;
           }
           if(!sleep)
            {
              console.log('Controller not sleeping!');
              return;
            }
          //if(i === undefined) i = 0;
          let tokens = lines[i].split(" ");
        if(tokens[0] == "mov"){
            if(tokens[1])
            {
              if(connections[tokens[2]] == 'pin1' || connections[tokens[2]] == 'pin2'){
                let power = 0;
                if(tokens[1] == "acc") power = test.acc;
                else power = parseInt(tokens[1]);
                led.power = power;
              }
              else if(tokens[2] == 'acc')
              {
                test.acc = parseInt(tokens[1]);
                let prefix = "";
                if(test.acc < 100) prefix += "0";
                if(test.acc < 10) prefix += "0"
                test.acc_text.text(prefix + test.acc);
              }
            }}
        else if(tokens[0] == "slp")
        {
          if(i+1 < lines.length) inst_index = i+1;
          i++;
          sleep_timer = parseInt(tokens[1]);
          return i;
        }
        else if(tokens[0] == "add")
        {
          test.acc += parseInt(tokens[1]);
          console.log(parseInt(tokens[1]));
          console.log(test.acc);
          let prefix = "";
          if(test.acc < 100) prefix += "0";
          if(test.acc < 10) prefix += "0";
          test.acc_text.text(prefix + test.acc);
        }
        else if(tokens[0] == "teq")
          {
            let equal = false;
            if(tokens[1] == "acc" && test.acc == parseInt(tokens[2])) equal = true;
            else if(tokens[2] == "acc" && test.acc == parseInt(tokens[1])) equal = true;
            else if(parseInt(tokens[1]) == parseInt(tokens[2])) equal = true;
            if(equal)
            {
              i++;
              if(i < lines.length) tokens = lines[i].split(" ");
              while(i < lines.length && tokens[0] == "+")
              {
                console.log("recursive call")
                tokens = lines[i].split(" ");
                processInput(tokens.slice(1));
                i++;
              }
            }
          }
          i++;
          if(i >= lines.length)
          {
            i = 0;
            inst_index = 0;
          }
        }
        
      }
      
      edit_mode = false;

    }, 100); // Execute every tenth of a second (100 ms)


  </script>
</html>
